{"version":3,"file":"index.js","mappings":"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","sources":["webpack://@blockly/plugin-scroll-options/webpack/universalModuleDefinition","webpack://@blockly/plugin-scroll-options/external umd {\"root\":\"Blockly\",\"commonjs\":\"blockly/core\",\"commonjs2\":\"blockly/core\",\"amd\":\"blockly/core\"}","webpack://@blockly/plugin-scroll-options/webpack/bootstrap","webpack://@blockly/plugin-scroll-options/webpack/runtime/define property getters","webpack://@blockly/plugin-scroll-options/webpack/runtime/hasOwnProperty shorthand","webpack://@blockly/plugin-scroll-options/webpack/runtime/make namespace object","webpack://@blockly/plugin-scroll-options/./src/ScrollMetricsManager.ts","webpack://@blockly/plugin-scroll-options/./src/utils.ts","webpack://@blockly/plugin-scroll-options/./src/AutoScroll.ts","webpack://@blockly/plugin-scroll-options/./src/AutoScrollable.ts","webpack://@blockly/plugin-scroll-options/./src/ScrollBlockDragger.ts","webpack://@blockly/plugin-scroll-options/./src/index.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"blockly/core\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"blockly/core\"], factory);\n\telse {\n\t\tvar a = typeof exports === 'object' ? factory(require(\"blockly/core\")) : factory(root[\"Blockly\"]);\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(this, (__WEBPACK_EXTERNAL_MODULE__370__) => {\nreturn ","module.exports = __WEBPACK_EXTERNAL_MODULE__370__;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as Blockly from 'blockly/core';\n\n/**\n * The MetricsManager reports various metrics about the workspace. This version\n * of the MetricsManager adds optional cacheing of the workspace content\n * metrics. Cached content metrics are useful if, for example, you are in the\n * middle of dragging a block, but want to get the bounds of the content area as\n * if you hadn't yet picked up the block.\n *\n * To use the cached value of the content metrics instead of calculating new\n * ones, set `useCachedContentMetrics` to true before calling `getMetrics`\n * false when the metrics can be recalculated again.\n */\nexport class ScrollMetricsManager extends Blockly.MetricsManager {\n  /**\n   * Whether to stop recalculating content metrics and used the cached value\n   * instead. Note that if there are no cached metrics, they will be\n   * recalculated even if this value is true.\n   */\n  useCachedContentMetrics = false;\n  /**\n   * Cached content metrics, if available.\n   */\n  contentMetrics: Blockly.MetricsManager.ContainerRegion | null = null;\n\n  /** @override */\n  getContentMetrics() {\n    if (this.useCachedContentMetrics && this.contentMetrics) {\n      return this.contentMetrics;\n    }\n\n    this.contentMetrics = super.getContentMetrics();\n    return this.contentMetrics;\n  }\n}\n\n/**\n * A MetricsManager that includes the ability to cache the content metrics.\n * Plugin authors may write their own MetricsManagers that do not necessarily\n * inherit from the ScrollMetricsManagers, e.g. to use multiple plugins together.\n * We can't assume the base class, but we can assert the MetricsManager provided\n * has the necessary property.\n */\nexport type CacheableMetricsManager = Blockly.IMetricsManager & {\n  useCachedContentMetrics: boolean;\n};\n\n/**\n * Checks if a MetricsManager supports cacheing content metrics.\n *\n * @param metricsManager\n */\nexport function isCacheable(\n  metricsManager: Blockly.IMetricsManager,\n): metricsManager is CacheableMetricsManager {\n  return (\n    (metricsManager as CacheableMetricsManager).useCachedContentMetrics !==\n    undefined\n  );\n}\n","/**\n * @license\n * Copyright 2022 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as Blockly from 'blockly/core';\n\n/**\n * Gets the current location of the workspace considering\n * when there's no drag surface.\n *\n * @param ws The workspace to calculate.\n * @returns The current workspace coordinate.\n */\nexport const getTranslation = (\n  ws: Blockly.WorkspaceSvg,\n): Blockly.utils.Coordinate => {\n  // TODO(blockly/#7157): We should maybe make getBlockCanvas public?\n  const translation = ws.svgBlockCanvas_.getAttribute('transform');\n  if (!translation)\n    throw new Error(`svgBlockCanvas has no attribute 'transform'`);\n\n  // Translation has the format 'translate(x, y)'.\n  const splitted = translation.split(',');\n  const x = Number(splitted[0].split('(')[1]);\n  const y = Number(splitted[1].split(')')[0]);\n  return new Blockly.utils.Coordinate(x, y);\n};\n","/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as Blockly from 'blockly/core';\nimport {isCacheable} from './ScrollMetricsManager';\nimport {getTranslation} from './utils';\nimport {ScrollBlockDragger} from './ScrollBlockDragger';\n\n/* eslint-disable @typescript-eslint/naming-convention */\n\n/**\n * AutoScroll is used to scroll/pan the workspace automatically. For example,\n * when a user drags a block near the edge of the workspace, it can begin\n * automatically scrolling in that direction.\n *\n * Call `updateProperties` with a vector containing scroll velocity in each\n * direction, in pixels per ms. AutoScroll will use animation frames to smoothly\n * scroll the workspace at a constant velocity. Call `stopAndDestroy` to cancel\n * the AutoScroll animation. You must ensure this is called eventually, or you\n * may get stuck in an infinite animation loop and crash the browser.\n */\nexport class AutoScroll {\n  /** Workspace to scroll. */\n  protected workspace_: Blockly.WorkspaceSvg;\n  protected dragger: ScrollBlockDragger;\n  /**\n   * Current active vector representing scroll velocity in pixels per\n   * millisecond in each direction.\n   */\n  protected activeScrollVector_ = new Blockly.utils.Coordinate(0, 0);\n  /** ID of active requestAnimationFrame callback key. */\n  protected animationFrameId_ = 0;\n  /** Time in ms last animation frame was run. */\n  protected lastTime_: number = Date.now();\n  /**\n   * Whether the scroll animation should continue. If this is false, the next\n   * animation frame will not be requested.\n   */\n  protected shouldAnimate_ = false;\n\n  /**\n   * Creates an AutoScroll instance for a specified workspace.\n   *\n   * @param workspace Workspace to scroll.\n   * @param dragger The dragger that's currently dragging.\n   * @constructor\n   */\n  constructor(workspace: Blockly.WorkspaceSvg, dragger: ScrollBlockDragger) {\n    this.workspace_ = workspace;\n    this.dragger = dragger;\n  }\n\n  /**\n   * Cancels the current autoscroll and resets properties.\n   */\n  stopAndDestroy() {\n    this.activeScrollVector_ = new Blockly.utils.Coordinate(0, 0);\n    this.shouldAnimate_ = false;\n    cancelAnimationFrame(this.animationFrameId_);\n    this.animationFrameId_ = 0;\n  }\n\n  /**\n   * Ticks scrolling behavior and triggers another\n   * frame request.\n   *\n   * @param now Current time in ms. This is usually passed\n   *     automatically by `requestAnimationFrame`.\n   */\n  protected nextAnimationStep_(now: number) {\n    if (this.shouldAnimate_) {\n      const delta = now - this.lastTime_;\n      this.lastTime_ = now;\n      // This method could be called multiple times per ms, and we only want to\n      // scroll if we should actually move.\n      if (delta > 0) {\n        this.scrollTick_(delta);\n      }\n\n      this.animationFrameId_ = requestAnimationFrame((time) =>\n        this.nextAnimationStep_(time),\n      );\n    }\n  }\n\n  /**\n   * Perform scroll given time passed.\n   *\n   * @param msPassed Number of ms since last scroll tick.\n   */\n  protected scrollTick_(msPassed: number) {\n    const scrollDx = this.activeScrollVector_.x * msPassed;\n    const scrollDy = this.activeScrollVector_.y * msPassed;\n    this.scrollWorkspaceWithBlock(scrollDx, scrollDy);\n  }\n\n  /**\n   * Scrolls the workspace the given amount during a block drag.\n   * Also updates the dragger based on the amount actually scrolled.\n   *\n   * @param scrollDx Amount to scroll in horizontal direction.\n   * @param scrollDy Amount to scroll in vertical direction.\n   */\n  scrollWorkspaceWithBlock(scrollDx: number, scrollDy: number) {\n    const oldLocation = getTranslation(this.workspace_);\n\n    // As we scroll, we shouldn't expand past the content area that existed\n    // before the block was picked up. Therefore, we use cached ContentMetrics\n    // so that the content area does not change as we scroll.\n    const metricsManager = this.workspace_.getMetricsManager();\n\n    if (!isCacheable(metricsManager)) {\n      console.warn(\n        'MetricsManager must be able to cache metrics in order to use AutoScroll',\n      );\n      return;\n    }\n    metricsManager.useCachedContentMetrics = true;\n    const newX = this.workspace_.scrollX + scrollDx;\n    const newY = this.workspace_.scrollY + scrollDy;\n    this.workspace_.scroll(newX, newY);\n    metricsManager.useCachedContentMetrics = false;\n\n    const newLocation = getTranslation(this.workspace_);\n\n    // How much we actually ended up scrolling.\n    const deltaX = newLocation.x - oldLocation.x;\n    const deltaY = newLocation.y - oldLocation.y;\n\n    // If we did scroll, we need to let the dragger know by how much.\n    // The dragger will update its values so that things like connection\n    // markers will stay consistent.\n    if (deltaX || deltaY) {\n      this.dragger.moveBlockWhileDragging(deltaX, deltaY);\n    }\n  }\n\n  /**\n   * Updates the scroll vector for the current autoscroll and begins the\n   * animation if needed.\n   *\n   * @param scrollVector New scroll velocity vector\n   *     in pixels per ms.\n   */\n  updateProperties(scrollVector: Blockly.utils.Coordinate) {\n    this.activeScrollVector_ = scrollVector;\n    this.shouldAnimate_ = true;\n\n    // Start new animation if there isn't one going.\n    if (this.animationFrameId_ == 0) {\n      this.lastTime_ = Date.now();\n      this.nextAnimationStep_(this.lastTime_);\n    }\n  }\n}\n","/**\n * @license\n * Copyright 2024 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as Blockly from 'blockly/core';\n\n/** A Draggable that can be autoscrolled. */\nexport interface AutoScrollable extends Blockly.IDraggable {\n  /**\n   * Returns the coordinates of a bounding box describing the dimensions of\n   * this draggable. This is necessary to detect when edge scrolling\n   * should activate.\n   */\n  getBoundingRectangle: () => Blockly.utils.Rect;\n}\n\n/**\n * Checks if the draggable implements the AutoScrollable interface.\n *\n * @param draggable\n * @returns true if draggable is also AutoScrollable\n */\nexport function isAutoScrollable(\n  draggable: Blockly.IDraggable,\n): draggable is AutoScrollable {\n  return (\n    typeof (draggable as AutoScrollable).getBoundingRectangle === 'function'\n  );\n}\n","/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as Blockly from 'blockly/core';\nimport {AutoScroll} from './AutoScroll';\nimport {isAutoScrollable} from './AutoScrollable';\n\n/* eslint-disable @typescript-eslint/naming-convention */\n\ntype CandidateScrolls = Record<string, Blockly.utils.Coordinate[]>;\n\nexport interface EdgeScrollOptions {\n  /** Pixels per ms to scroll when the block is near the edge of the workspace. */\n  slowBlockSpeed: number;\n  /**\n   * Pixels per ms to scroll when the block is\n   * far past the edge of the workspace.\n   */\n  fastBlockSpeed: number;\n  /**\n   * Distance in workspace units that\n   * the edge of the block is from the edge of the viewport before the\n   * corresponding scroll speed will be used. Can be negative to start scrolling\n   * before the block extends over the edge.\n   */\n  slowBlockStartDistance: number;\n  /**\n   * Same as above, for fast speed.\n   * Must be larger than `slowBlockStartDistance`.\n   */\n  fastBlockStartDistance: number;\n  /**\n   * If a block takes up this\n   * percentage of the viewport or more, it will be considered oversized. Rather\n   * than using the block edge, we use the mouse cursor plus the given margin size\n   * to activate block-based scrolling.\n   */\n  oversizeBlockThreshold: number;\n  /**\n   * Cursor margin to use for oversized\n   * blocks. A bigger value will cause the workspace to scroll sooner, i.e., the\n   * mouse can be further inward from the edge when scrolling begins.\n   */\n  oversizeBlockMargin: number;\n  /**\n   * Pixels per ms to\n   * scroll when the mouse is near the edge of the workspace.\n   */\n  slowMouseSpeed: number;\n  /**\n   * Pixels per ms to\n   * scroll when the mouse is far past the edge of the workspace.\n   */\n  fastMouseSpeed: number;\n  /**\n   * Distance in workspace units that\n   * the mouse is from the edge of the viewport before the corresponding scroll\n   * speed will be used. Can be negative to start scrolling before the mouse\n   * extends over the edge.\n   */\n  slowMouseStartDistance: number;\n  /**\n   * Same as above, for fast speed.\n   * Must be larger than `slowMouseStartDistance`.\n   */\n  fastMouseStartDistance: number;\n}\n\nconst defaultOptions: EdgeScrollOptions = {\n  slowBlockSpeed: 0.28,\n  fastBlockSpeed: 1.4,\n  slowBlockStartDistance: 0,\n  fastBlockStartDistance: 50,\n  oversizeBlockThreshold: 0.85,\n  oversizeBlockMargin: 15,\n  slowMouseSpeed: 0.5,\n  fastMouseSpeed: 1.6,\n  slowMouseStartDistance: 0,\n  fastMouseStartDistance: 35,\n};\n\n/**\n * A block dragger that adds the functionality for a block to be moved while\n * someone is dragging it.\n */\nexport class ScrollBlockDragger extends Blockly.dragging.Dragger {\n  /** How much the block has been moved due to scrolling. */\n  protected scrollDelta_ = new Blockly.utils.Coordinate(0, 0);\n  /** How much the block has been moved due to dragging. */\n  protected dragDelta_ = new Blockly.utils.Coordinate(0, 0);\n\n  // TODO(maribethb): Use `isMoveable` etc. to get this list\n  /** Possible directions the workspace could be scrolled. */\n  protected scrollDirections_: ['top', 'bottom', 'left', 'right'] = [\n    'top',\n    'bottom',\n    'left',\n    'right',\n  ];\n\n  /**\n   * Unit vector for each direction that could be scrolled. This vector will\n   * be scaled to get the calculated velocity in each direction.\n   */\n  private SCROLL_DIRECTION_VECTORS_ = {\n    top: new Blockly.utils.Coordinate(0, 1),\n    bottom: new Blockly.utils.Coordinate(0, -1),\n    left: new Blockly.utils.Coordinate(1, 0),\n    right: new Blockly.utils.Coordinate(-1, 0),\n  };\n\n  activeAutoScroll_: AutoScroll | null = null;\n\n  /**\n   * Whether the behavior to scroll the workspace when a block is dragged near\n   * the edge is enabled.\n   */\n  static edgeScrollEnabled = true;\n  /** Configuration options for the scroll-options settings. */\n  static options: EdgeScrollOptions = defaultOptions;\n\n  /**\n   * Updates the location of the block that is being dragged.\n   *\n   * @param deltaX Horizontal offset in pixel units.\n   * @param deltaY Vertical offset in pixel units.\n   */\n  moveBlockWhileDragging(deltaX: number, deltaY: number): void {\n    // If this object can't be autoscrolled, give up\n    if (!isAutoScrollable(this.draggable)) return;\n\n    this.scrollDelta_.x -= deltaX;\n    this.scrollDelta_.y -= deltaY;\n\n    // The total amount the block has moved since being picked up.\n    const totalDelta = Blockly.utils.Coordinate.sum(\n      this.scrollDelta_,\n      this.dragDelta_,\n    );\n\n    const delta = this.pixelsToWorkspaceUnits(totalDelta);\n    const newLoc = Blockly.utils.Coordinate.sum(this.startLoc, delta);\n\n    // Make the block stay under the cursor.\n    this.draggable.drag(newLoc);\n  }\n\n  /**\n   * Passes the total amount the block has moved (both from dragging and from\n   * scrolling) since it was picked up.\n   *\n   * @override\n   */\n  onDrag(e: PointerEvent, dragDelta: Blockly.utils.Coordinate) {\n    const totalDelta = Blockly.utils.Coordinate.sum(\n      this.scrollDelta_,\n      dragDelta,\n    );\n    super.onDrag(e, totalDelta);\n    this.dragDelta_ = dragDelta;\n\n    if (ScrollBlockDragger.edgeScrollEnabled) {\n      this.scrollWorkspaceWhileDragging_(e);\n    }\n  }\n\n  /**\n   * @override\n   */\n  onDragEnd(e: PointerEvent) {\n    super.onDragEnd(e);\n    this.stopAutoScrolling();\n  }\n\n  /**\n   * May scroll the workspace as a block is dragged.\n   * If a block is dragged near the edge of the workspace, this method will\n   * cause the workspace to scroll in the direction the block is being\n   * dragged. The workspace will not resize as the block is dragged. The\n   * workspace should appear to move out from under the block, i.e., the block\n   * should stay under the user's mouse.\n   *\n   * @param e The mouse/touch event for the drag.\n   */\n  protected scrollWorkspaceWhileDragging_(e: PointerEvent) {\n    // If this object can't be autoscrolled, give up\n    if (!isAutoScrollable(this.draggable)) return;\n\n    const mouse = Blockly.utils.svgMath.screenToWsCoordinates(\n      this.workspace,\n      new Blockly.utils.Coordinate(e.clientX, e.clientY),\n    );\n\n    /**\n     * List of possible scrolls in each direction. This will be modified in\n     * place.\n     */\n    const candidateScrolls: CandidateScrolls = {\n      top: [],\n      bottom: [],\n      left: [],\n      right: [],\n    };\n\n    // Get ViewMetrics in workspace coordinates.\n    const viewMetrics = this.workspace.getMetricsManager().getViewMetrics(true);\n\n    // Get possible scroll velocities based on the location of both the block\n    // and the mouse.\n    this.computeBlockCandidateScrolls_(candidateScrolls, viewMetrics, mouse);\n    this.computeMouseCandidateScrolls_(candidateScrolls, viewMetrics, mouse);\n    // Calculate the final scroll vector we should actually use.\n    const overallScrollVector = this.getOverallScrollVector_(candidateScrolls);\n\n    // If the workspace should not be scrolled any longer, cancel the\n    // autoscroll.\n    if (\n      Blockly.utils.Coordinate.equals(\n        overallScrollVector,\n        new Blockly.utils.Coordinate(0, 0),\n      )\n    ) {\n      this.stopAutoScrolling();\n      return;\n    }\n\n    // Update the autoscroll or start a new one.\n    this.activeAutoScroll_ =\n      this.activeAutoScroll_ || new AutoScroll(this.workspace, this);\n    this.activeAutoScroll_.updateProperties(overallScrollVector);\n  }\n\n  /**\n   * There could be multiple candidate scrolls for each direction, such as one\n   * for block position and one for mouse position. We should first find the\n   * fastest scroll in each direction. Then, we sum those to find the overall\n   * scroll vector.\n   *\n   * For example, we may have a fast block scroll and a slow\n   * mouse scroll candidate in both the top and left directions. First, we\n   * reduce to only the fast block scroll. Then, we sum the vectors in each\n   * direction to get a resulting fast scroll in a diagonal direction to the\n   * top left.\n   *\n   * @param candidateScrolls Existing lists of candidate\n   *     scrolls. Will be modified in place.\n   * @returns Overall scroll vector.\n   */\n  protected getOverallScrollVector_(\n    candidateScrolls: CandidateScrolls,\n  ): Blockly.utils.Coordinate {\n    let overallScrollVector = new Blockly.utils.Coordinate(0, 0);\n    for (const direction of this.scrollDirections_) {\n      const fastestScroll = candidateScrolls[direction].reduce(\n        (fastest, current) => {\n          if (!fastest) {\n            return current;\n          }\n          return Blockly.utils.Coordinate.magnitude(fastest) >\n            Blockly.utils.Coordinate.magnitude(current)\n            ? fastest\n            : current;\n        },\n        new Blockly.utils.Coordinate(0, 0),\n      ); // Initial value\n      overallScrollVector = Blockly.utils.Coordinate.sum(\n        overallScrollVector,\n        fastestScroll,\n      );\n    }\n    return overallScrollVector;\n  }\n\n  /**\n   * Gets the candidate scrolls based on the position of the block on the\n   * workspace. If the block is near/over the edge, a candidate scroll will be\n   * added based on the options provided.\n   *\n   * This method can be overridden to further customize behavior, e.g. To add\n   * a third speed option.\n   *\n   * @param candidateScrolls Existing list of candidate\n   *     scrolls. Will be modified in place.\n   * @param viewMetrics View metrics for the workspace.\n   * @param mouse Mouse coordinates.\n   */\n  protected computeBlockCandidateScrolls_(\n    candidateScrolls: CandidateScrolls,\n    viewMetrics: Blockly.MetricsManager.ContainerRegion,\n    mouse: Blockly.utils.Coordinate,\n  ): void {\n    const blockOverflows = this.getBlockBoundsOverflows_(viewMetrics, mouse);\n    for (const direction of this.scrollDirections_) {\n      const overflow = blockOverflows[direction];\n      if (overflow > ScrollBlockDragger.options.slowBlockStartDistance) {\n        const speed =\n          overflow > ScrollBlockDragger.options.fastBlockStartDistance\n            ? ScrollBlockDragger.options.fastBlockSpeed\n            : ScrollBlockDragger.options.slowBlockSpeed;\n        const scrollVector = this.SCROLL_DIRECTION_VECTORS_[direction]\n          .clone()\n          .scale(speed);\n        candidateScrolls[direction].push(scrollVector);\n      }\n    }\n  }\n\n  /**\n   * Gets the candidate scrolls based on the position of the mouse cursor\n   * relative to the workspace. If the mouse is near/over the edge, a\n   * candidate scroll will be added based on the options provided.\n   *\n   * This method can be overridden to further customize behavior, e.g. To add\n   * a third speed option.\n   *\n   * @param candidateScrolls Existing list of candidate\n   *     scrolls. Will be modified in place.\n   * @param viewMetrics View metrics for the workspace.\n   * @param mouse Mouse coordinates.\n   */\n  protected computeMouseCandidateScrolls_(\n    candidateScrolls: CandidateScrolls,\n    viewMetrics: Blockly.MetricsManager.ContainerRegion,\n    mouse: Blockly.utils.Coordinate,\n  ) {\n    const mouseOverflows = this.getMouseOverflows_(viewMetrics, mouse);\n    for (const direction of this.scrollDirections_) {\n      const overflow = mouseOverflows[direction];\n      if (overflow > ScrollBlockDragger.options.slowMouseStartDistance) {\n        const speed =\n          overflow > ScrollBlockDragger.options.fastMouseStartDistance\n            ? ScrollBlockDragger.options.fastMouseSpeed\n            : ScrollBlockDragger.options.slowMouseSpeed;\n        const scrollVector = this.SCROLL_DIRECTION_VECTORS_[direction]\n          .clone()\n          .scale(speed);\n        candidateScrolls[direction].push(scrollVector);\n      }\n    }\n  }\n\n  /**\n   * Gets the amount of overflow of a box relative to the workspace viewport.\n   *\n   * The value for each direction will be how far the given block edge is from\n   * the given edge of the viewport. If the block edge is outside the\n   * viewport, the value will be positive. If the block edge is inside the\n   * viewport, the value will be negative.\n   *\n   * This method also checks for oversized blocks. If the block is very large\n   * relative to the viewport size, then we will actually use a small zone\n   * around the cursor, rather than the edge of the block, to calculate the\n   * overflow values. This calculation is done independently in both the\n   * horizontal and vertical directions. These values can be configured in the\n   * options for the plugin.\n   *\n   * @param viewMetrics View metrics for the workspace.\n   * @param mouse Mouse coordinates.\n   */\n  protected getBlockBoundsOverflows_(\n    viewMetrics: Blockly.MetricsManager.ContainerRegion,\n    mouse: Blockly.utils.Coordinate,\n  ): {[key: string]: number} {\n    // This function shouldn't be called in the first place if the object\n    // isn't autoscrollable, but return some sane data anyway\n    if (!isAutoScrollable(this.draggable)) {\n      return {\n        top: 0,\n        bottom: 0,\n        left: 0,\n        right: 0,\n      };\n    }\n    const blockBounds = this.draggable.getBoundingRectangle();\n\n    // Handle large blocks. If the block is nearly as tall as the viewport,\n    // use a margin around the cursor rather than the height of the block.\n    const blockHeight = blockBounds.bottom - blockBounds.top;\n    if (\n      blockHeight >\n      viewMetrics.height * ScrollBlockDragger.options.oversizeBlockThreshold\n    ) {\n      blockBounds.top = Math.max(\n        blockBounds.top,\n        mouse.y - ScrollBlockDragger.options.oversizeBlockMargin,\n      );\n      blockBounds.bottom = Math.min(\n        blockBounds.bottom,\n        mouse.y + ScrollBlockDragger.options.oversizeBlockMargin,\n      );\n    }\n\n    // Same logic, but for block width.\n    const blockWidth = blockBounds.right - blockBounds.left;\n    if (\n      blockWidth >\n      viewMetrics.width * ScrollBlockDragger.options.oversizeBlockThreshold\n    ) {\n      blockBounds.left = Math.max(\n        blockBounds.left,\n        mouse.x - ScrollBlockDragger.options.oversizeBlockMargin,\n      );\n      blockBounds.right = Math.min(\n        blockBounds.right,\n        mouse.x + ScrollBlockDragger.options.oversizeBlockMargin,\n      );\n    }\n\n    // The coordinate system is negative in the top and left directions, and\n    // positive in the bottom and right directions. Therefore, the direction\n    // of the comparison must be switched for bottom and right.\n    return {\n      top: viewMetrics.top - blockBounds.top,\n      bottom: -(viewMetrics.top + viewMetrics.height - blockBounds.bottom),\n      left: viewMetrics.left - blockBounds.left,\n      right: -(viewMetrics.left + viewMetrics.width - blockBounds.right),\n    };\n  }\n\n  /**\n   * Gets the amount of overflow of the mouse coordinates relative to the\n   * viewport.\n   *\n   * The value for each direction will be how far the pointer is from\n   * the given edge of the viewport. If the pointer is outside the viewport,\n   * the value will be positive. If the pointer is inside the viewport, the\n   * value will be negative.\n   *\n   * @param viewMetrics View metrics\n   *     for the workspace.\n   * @param mouse Mouse coordinates.\n   * @returns An object describing the amount of\n   *     overflow in each direction.\n   */\n  protected getMouseOverflows_(\n    viewMetrics: Blockly.MetricsManager.ContainerRegion,\n    mouse: Blockly.utils.Coordinate,\n  ): {[key: string]: number} {\n    // The coordinate system is negative in the top and left directions, and\n    // positive in the bottom and right directions. Therefore, the direction\n    // of the comparison must be switched for bottom and right.\n    return {\n      top: viewMetrics.top - mouse.y,\n      bottom: -(viewMetrics.top + viewMetrics.height - mouse.y),\n      left: viewMetrics.left - mouse.x,\n      right: -(viewMetrics.left + viewMetrics.width - mouse.x),\n    };\n  }\n\n  /**\n   * Cancel any AutoScroll. This must be called when there is no need to\n   * scroll further, e.g., when no longer dragging near the edge of the\n   * workspace, or when no longer dragging at all.\n   */\n  stopAutoScrolling() {\n    if (this.activeAutoScroll_) {\n      this.activeAutoScroll_.stopAndDestroy();\n    }\n    this.activeAutoScroll_ = null;\n  }\n\n  /**\n   * Update the scroll options. Only the properties actually included in the\n   * `options` parameter will be set. Any unspecified options will use the\n   * previously set value (where the initial value is from `defaultOptions`).\n   * Therefore, do not pass in any options with explicit `undefined` or `null`\n   * values. The plugin will break. Just leave them out of the object if you\n   * don't want to change the default value.\n   *\n   * This method is safe to call multiple times. Subsequent calls will add onto\n   * previous calls, not completely overwrite them. That is, if you call this\n   * with:\n   *\n   * `updateOptions({fastMouseSpeed: 5});\n   * updateOptions({slowMouseSpeed: 2});`.\n   *\n   * Then the final options used will include both `fastMouseSpeed: 5` and\n   * `slowMouseSpeed: 2` with all other options being the default values.\n   *\n   * @param options Object containing any or all of\n   *     the available options. Any properties not present will use the existing\n   *     value.\n   */\n  static updateOptions = function (options: Partial<EdgeScrollOptions>) {\n    ScrollBlockDragger.options = {...ScrollBlockDragger.options, ...options};\n  };\n\n  /**\n   * Resets the options object to the default options.\n   */\n  static resetOptions = function () {\n    ScrollBlockDragger.options = defaultOptions;\n  };\n}\n\nBlockly.registry.register(\n  Blockly.registry.Type.BLOCK_DRAGGER,\n  'ScrollBlockDragger',\n  ScrollBlockDragger,\n);\n","/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as Blockly from 'blockly/core';\nimport {EdgeScrollOptions, ScrollBlockDragger} from './ScrollBlockDragger';\nimport {getTranslation} from './utils';\nimport {isCacheable} from './ScrollMetricsManager';\n\n/* eslint-disable @typescript-eslint/naming-convention */\n\n/**\n * A Blockly plugin that adds additional features related to scrolling and\n * dragging on workspaces. This plugin adds the ability to: a) use the\n * mousewheel to scroll the workspace while a block is being dragged, and b)\n * scroll the workspace automatically when a block is dragged near the edge.\n *\n * All behavior is customizable. See the README for more information.\n */\nexport class ScrollOptions {\n  protected workspace_: Blockly.WorkspaceSvg;\n\n  /** Bound event listener for the scroll wheel event. */\n  protected wheelEvent_: Blockly.browserEvents.Data | null = null;\n\n  /**\n   * Constructor for ScrollOptions plugin.\n   *\n   * @param workspace The workspace that the plugin will\n   *     be added to.\n   */\n  constructor(workspace: Blockly.WorkspaceSvg) {\n    this.workspace_ = workspace;\n  }\n\n  /**\n   * Initialize plugin with optional options. If no options are provided, both\n   * plugin features are enabled with default settings. The plugin is configured\n   * here as a convenience. See the README for more information on configuring\n   * the plugin after initialization.\n   *\n   * @param root0\n   * @param root0.enableWheelScroll\n   * @param root0.enableEdgeScroll\n   * @param root0.edgeScrollOptions\n   *\n   *  options The\n   * configuration options for the plugin. `enableWheelScroll` and\n   * `enableEdgeScroll` are both true by default and control whether the\n   * behavior to scroll with the mouse wheel while dragging and scroll when a\n   * block is near the edge of the workspace are enabled, respectively.\n   * `edgeScrollOptions` is an optional configuration for the edge scrolling\n   * behavior. See `ScrollBlockDrager.updateOptions` for more details.\n   */\n  init(\n    {\n      enableWheelScroll = true,\n      enableEdgeScroll = true,\n      edgeScrollOptions = undefined,\n    }:\n      | {\n          enableWheelScroll?: boolean;\n          enableEdgeScroll?: boolean;\n          edgeScrollOptions?: Partial<EdgeScrollOptions>;\n        }\n      | undefined = {\n      enableWheelScroll: true,\n      enableEdgeScroll: true,\n      edgeScrollOptions: undefined,\n    },\n  ) {\n    if (enableWheelScroll) {\n      this.enableWheelScroll();\n    } else {\n      this.disableWheelScroll();\n    }\n\n    ScrollBlockDragger.edgeScrollEnabled = enableEdgeScroll;\n\n    if (edgeScrollOptions) {\n      ScrollBlockDragger.updateOptions(edgeScrollOptions);\n    }\n  }\n\n  /**\n   * Enables scrolling with mousewheel during block drag.\n   */\n  enableWheelScroll() {\n    if (this.wheelEvent_) {\n      // Already enabled.\n      return;\n    }\n\n    // We need to attach the event listener to the drag surface in order\n    // to hear the wheel event while a drag is in progress.\n    // TODO(google/blockly#8135): Use the layer manager if possible.\n    const dragLayer = this.workspace_\n      .getInjectionDiv()\n      .getElementsByClassName('blocklyBlockDragSurface')[0];\n    if (!dragLayer) {\n      throw new Error(\n        `Can't attach wheel listener to nonexistent drag surface`,\n      );\n    }\n\n    this.wheelEvent_ = Blockly.browserEvents.conditionalBind(\n      dragLayer,\n      'wheel',\n      this,\n      this.onMouseWheel_,\n    );\n  }\n\n  /**\n   * Disables scrolling with mousewheel during block drag.\n   */\n  disableWheelScroll() {\n    if (!this.wheelEvent_) {\n      // Already disabled.\n      return;\n    }\n    Blockly.browserEvents.unbind(this.wheelEvent_);\n    this.wheelEvent_ = null;\n  }\n\n  /**\n   * Enables scrolling when block is dragged near edge.\n   */\n  enableEdgeScroll() {\n    ScrollBlockDragger.edgeScrollEnabled = true;\n  }\n\n  /**\n   * Disables scrolling when block is dragged near edge.\n   */\n  disableEdgeScroll() {\n    ScrollBlockDragger.edgeScrollEnabled = false;\n  }\n\n  /**\n   * Updates edge scroll options. See ScrollBlockDragger for specific settings.\n   * Any values left unspecified will not be overwritten and will retain their\n   * previous values.\n   *\n   * @param options Edge scroll options.\n   */\n  updateEdgeScrollOptions(options: Partial<EdgeScrollOptions>) {\n    ScrollBlockDragger.updateOptions(options);\n  }\n\n  /**\n   * Scrolls the workspace with the mousewheel while a block is being dragged.\n   * Translates the currently dragged block as the user scrolls the workspace,\n   * so that the block does not appear to move.\n   *\n   * @param e Mouse wheel event.\n   */\n  onMouseWheel_(e: WheelEvent) {\n    const canWheelMove =\n      this.workspace_.options.moveOptions &&\n      this.workspace_.options.moveOptions.wheel;\n    // All we want to do is get the currentGesture from the workspace so\n    // that we can get the dragger from it.\n    // getGesture expects a PointerEvent, but we don't have one. As long\n    // as the event we give it isn't a 'pointerdown' event, we'll get the\n    // current gesture if there is one, or null if there isn't.\n    // TODO(google/blockly#8133): Remove the parameter when possible.\n    const currentGesture = this.workspace_.getGesture(\n      e as unknown as PointerEvent,\n    );\n\n    const metricsManager = this.workspace_.getMetricsManager();\n    if (!isCacheable(metricsManager)) {\n      console.warn(\n        'MetricsManager must be able to cache metrics in order to use AutoScroll',\n      );\n      return;\n    }\n\n    const dragger = currentGesture?.getCurrentDragger();\n\n    // Do not try to scroll if we are not dragging a block, or the workspace\n    // does not allow moving by wheel, or our dragger is not capable of this.\n    if (\n      !canWheelMove ||\n      !currentGesture ||\n      !(dragger instanceof ScrollBlockDragger)\n    ) {\n      return;\n    }\n\n    // Figure out the desired location to scroll to.\n    const scrollDelta = Blockly.browserEvents.getScrollDeltaPixels(e);\n    if (e.shiftKey) {\n      // Scroll horizontally (based on vertical scroll delta).\n      const temp = scrollDelta.x;\n      scrollDelta.x = scrollDelta.y;\n      scrollDelta.y = temp;\n    }\n    const x = this.workspace_.scrollX - scrollDelta.x;\n    const y = this.workspace_.scrollY - scrollDelta.y;\n\n    const oldLocation = getTranslation(this.workspace_);\n\n    // Try to scroll to the desired location.\n    metricsManager.useCachedContentMetrics = true;\n    this.workspace_.scroll(x, y);\n    metricsManager.useCachedContentMetrics = false;\n\n    const newLocation = getTranslation(this.workspace_);\n\n    // How much we actually ended up scrolling.\n    const deltaX = newLocation.x - oldLocation.x;\n    const deltaY = newLocation.y - oldLocation.y;\n\n    if (deltaX || deltaY) {\n      dragger.moveBlockWhileDragging(deltaX, deltaY);\n      e.preventDefault();\n    }\n  }\n}\n\nexport * from './ScrollBlockDragger';\nexport * from './ScrollMetricsManager';\nexport * from './AutoScrollable';\n"],"names":["root","factory","exports","module","require","define","amd","a","i","this","__WEBPACK_EXTERNAL_MODULE__370__","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","d","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","r","Symbol","toStringTag","value","ScrollMetricsManager","useCachedContentMetrics","contentMetrics","getContentMetrics","super","isCacheable","metricsManager","getTranslation","ws","translation","svgBlockCanvas_","getAttribute","Error","splitted","split","x","Number","y","Coordinate","AutoScroll","constructor","workspace","dragger","activeScrollVector_","animationFrameId_","lastTime_","Date","now","shouldAnimate_","workspace_","stopAndDestroy","cancelAnimationFrame","nextAnimationStep_","delta","scrollTick_","requestAnimationFrame","time","msPassed","scrollDx","scrollDy","scrollWorkspaceWithBlock","oldLocation","getMetricsManager","console","warn","newX","scrollX","newY","scrollY","scroll","newLocation","deltaX","deltaY","moveBlockWhileDragging","updateProperties","scrollVector","isAutoScrollable","draggable","getBoundingRectangle","defaultOptions","slowBlockSpeed","fastBlockSpeed","slowBlockStartDistance","fastBlockStartDistance","oversizeBlockThreshold","oversizeBlockMargin","slowMouseSpeed","fastMouseSpeed","slowMouseStartDistance","fastMouseStartDistance","ScrollBlockDragger","Dragger","scrollDelta_","dragDelta_","scrollDirections_","SCROLL_DIRECTION_VECTORS_","top","bottom","left","right","activeAutoScroll_","totalDelta","sum","pixelsToWorkspaceUnits","newLoc","startLoc","drag","onDrag","e","dragDelta","edgeScrollEnabled","scrollWorkspaceWhileDragging_","onDragEnd","stopAutoScrolling","mouse","svgMath","screenToWsCoordinates","clientX","clientY","candidateScrolls","viewMetrics","getViewMetrics","computeBlockCandidateScrolls_","computeMouseCandidateScrolls_","overallScrollVector","getOverallScrollVector_","equals","direction","fastestScroll","reduce","fastest","current","magnitude","blockOverflows","getBlockBoundsOverflows_","overflow","options","speed","clone","scale","push","mouseOverflows","getMouseOverflows_","blockBounds","height","Math","max","min","width","updateOptions","resetOptions","register","Type","BLOCK_DRAGGER","ScrollOptions","wheelEvent_","init","enableWheelScroll","enableEdgeScroll","edgeScrollOptions","disableWheelScroll","dragLayer","getInjectionDiv","getElementsByClassName","conditionalBind","onMouseWheel_","unbind","disableEdgeScroll","updateEdgeScrollOptions","canWheelMove","moveOptions","wheel","currentGesture","getGesture","getCurrentDragger","scrollDelta","getScrollDeltaPixels","shiftKey","temp","preventDefault"],"sourceRoot":""}